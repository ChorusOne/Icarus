// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package mainnet

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// LockedGoldABI is the input ABI used to generate the binding from.
const LockedGoldABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"getSlashingWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"decrementNonvotingAccountBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slasherIdentifier\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"removeSlasher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalLockedGold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountTotalLockedGold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"penalty\",\"type\":\"uint256\"},{\"name\":\"reporter\",\"type\":\"address\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"lessers\",\"type\":\"address[]\"},{\"name\":\"greaters\",\"type\":\"address[]\"},{\"name\":\"indices\",\"type\":\"uint256[]\"}],\"name\":\"slash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getAccountNonvotingLockedGold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slasher\",\"type\":\"address\"}],\"name\":\"isSlasher\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"unlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slasherIdentifier\",\"type\":\"string\"}],\"name\":\"addSlasher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setUnlockingPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"slashingWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"incrementNonvotingAccountBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonvotingLockedGold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"relock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getTotalPendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalNonvoting\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"registryAddress\",\"type\":\"address\"},{\"name\":\"_unlockingPeriod\",\"type\":\"uint256\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lock\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"UnlockingPeriodSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GoldLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"available\",\"type\":\"uint256\"}],\"name\":\"GoldUnlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GoldRelocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"GoldWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slasherIdentifier\",\"type\":\"string\"}],\"name\":\"SlasherWhitelistAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slasherIdentifier\",\"type\":\"string\"}],\"name\":\"SlasherWhitelistRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slashed\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"penalty\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"reporter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"AccountSlashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"registryAddress\",\"type\":\"address\"}],\"name\":\"RegistrySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]"

// LockedGoldBin is the compiled bytecode used for deploying new contracts.
var LockedGoldBin = "0x60806040526001600090815561001c640100000000610077810204565b6001805461010060a860020a031916610100600160a060020a03841690810291909117909155604051919250906000907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908290a35061007b565b3390565b6130098061008a6000396000f3fe6080604052600436106101c65760003560e060020a900480636adcc938116100fb578063a91ee0dc11610099578063cd6dc68711610068578063cd6dc687146107bb578063f2fde38b146107f4578063f340c0d014610827578063f83d08ba146108f3576101c6565b8063a91ee0dc14610710578063b2fb30cb14610743578063b6e1e49d14610773578063c1867f6d146107a6576101c6565b80637b103999116100d55780637b103999146106a0578063807876b7146106d15780638da5cb5b146106e65780638f32d59b146106fb576101c6565b80636adcc938146106285780636edf77a514610652578063715018a61461068b576101c6565b806330ec70f51161016857806357601c5d1161014257806357601c5d146105245780636198e33914610557578063648911981461058157806366f0633b146105fe576101c6565b806330ec70f51461037757806331993fc9146103aa5780633f199b40146104f1576101c6565b80631fe2dfda116101a45780631fe2dfda1461029457806320637d8e146103115780632e1a7d4d1461033857806330a61d5914610362576101c6565b806308764ee2146101cb578063158ef93e1461023057806318a4ff8c14610259575b600080fd5b3480156101d757600080fd5b506101e06108fb565b60408051602080825283518183015283519192839290830191858101910280838360005b8381101561021c578181015183820152602001610204565b505050509050019250505060405180910390f35b34801561023c57600080fd5b50610245610954565b604080519115158252519081900360200190f35b34801561026557600080fd5b506102926004803603604081101561027c57600080fd5b50600160a060020a03813516906020013561095d565b005b3480156102a057600080fd5b50610292600480360360408110156102b757600080fd5b8101906020810181356401000000008111156102d257600080fd5b8201836020820111156102e457600080fd5b8035906020019184600183028401116401000000008311171561030657600080fd5b919350915035610a87565b34801561031d57600080fd5b50610326610cca565b60408051918252519081900360200190f35b34801561034457600080fd5b506102926004803603602081101561035b57600080fd5b5035610cd0565b34801561036e57600080fd5b50610326610f58565b34801561038357600080fd5b506103266004803603602081101561039a57600080fd5b5035600160a060020a0316610fe0565b3480156103b657600080fd5b50610292600480360360e08110156103cd57600080fd5b600160a060020a0382358116926020810135926040820135909216916060820135919081019060a08101608082013564010000000081111561040e57600080fd5b82018360208201111561042057600080fd5b8035906020019184602083028401116401000000008311171561044257600080fd5b91939092909160208101903564010000000081111561046057600080fd5b82018360208201111561047257600080fd5b8035906020019184602083028401116401000000008311171561049457600080fd5b9193909290916020810190356401000000008111156104b257600080fd5b8201836020820111156104c457600080fd5b803590602001918460208302840111640100000000831117156104e657600080fd5b50909250905061109c565b3480156104fd57600080fd5b506103266004803603602081101561051457600080fd5b5035600160a060020a031661154d565b34801561053057600080fd5b506102456004803603602081101561054757600080fd5b5035600160a060020a0316611568565b34801561056357600080fd5b506102926004803603602081101561057a57600080fd5b503561164c565b34801561058d57600080fd5b50610292600480360360208110156105a457600080fd5b8101906020810181356401000000008111156105bf57600080fd5b8201836020820111156105d157600080fd5b803590602001918460018302840111640100000000831117156105f357600080fd5b509092509050611a09565b34801561060a57600080fd5b506102926004803603602081101561062157600080fd5b5035611c6f565b34801561063457600080fd5b506103266004803603602081101561064b57600080fd5b5035611d50565b34801561065e57600080fd5b506102926004803603604081101561067557600080fd5b50600160a060020a038135169060200135611d6f565b34801561069757600080fd5b50610292611e94565b3480156106ac57600080fd5b506106b5611f3d565b60408051600160a060020a039092168252519081900360200190f35b3480156106dd57600080fd5b50610326611f4c565b3480156106f257600080fd5b506106b5611f52565b34801561070757600080fd5b50610245611f66565b34801561071c57600080fd5b506102926004803603602081101561073357600080fd5b5035600160a060020a0316611f91565b34801561074f57600080fd5b506102926004803603604081101561076657600080fd5b5080359060200135612094565b34801561077f57600080fd5b506103266004803603602081101561079657600080fd5b5035600160a060020a03166122fd565b3480156107b257600080fd5b506103266123d8565b3480156107c757600080fd5b50610292600480360360408110156107de57600080fd5b50600160a060020a0381351690602001356123de565b34801561080057600080fd5b506102926004803603602081101561081757600080fd5b5035600160a060020a0316612460565b34801561083357600080fd5b5061085a6004803603602081101561084a57600080fd5b5035600160a060020a03166124b8565b604051808060200180602001838103835285818151815260200191508051906020019060200280838360005b8381101561089e578181015183820152602001610886565b50505050905001838103825284818151815260200191508051906020019060200280838360005b838110156108dd5781810151838201526020016108c5565b5050505090500194505050505060405180910390f35b6102926126d3565b6060600580548060200260200160405190810160405280929190818152602001828054801561094957602002820191906000526020600020905b815481526020019060010190808311610935575b505050505090505b90565b60015460ff1681565b604080517f456c656374696f6e000000000000000000000000000000000000000000000000602080830191909152825160088184030181526028830180855281519183019190912060025460e060020a63dcf0aaed02909252602c840181905293513393600160a060020a039092169263dcf0aaed92604c8082019391829003018186803b1580156109ee57600080fd5b505afa158015610a02573d6000803e3d6000fd5b505050506040513d6020811015610a1857600080fd5b5051600160a060020a031614610a78576040805160e560020a62461bcd02815260206004820152601860248201527f6f6e6c79207265676973746572656420636f6e74726163740000000000000000604482015290519081900360640190fd5b610a82838361289f565b505050565b610a8f611f66565b1515610ad3576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b60008383604051602001808383808284376040805191909301818103601f190182528352805160209182012060008181526004909252929020549195505060ff1615159250610b599150505760405160e560020a62461bcd028152600401808060200182810382526027815260200180612f766027913960400191505060405180910390fd5b6005548210610b9c5760405160e560020a62461bcd028152600401808060200182810382526028815260200180612f4e6028913960400191505060405180910390fd5b80600583815481101515610bac57fe5b9060005260206000200154141515610c0e576040805160e560020a62461bcd02815260206004820152601e60248201527f496e64657820646f65736e2774206d61746368206964656e7469666965720000604482015290519081900360640190fd5b600580546000198101908110610c2057fe5b9060005260206000200154600583815481101515610c3a57fe5b60009182526020909120015560058054801515610c5357fe5b60008281526020808220830160001990810183905590920190925582825260049052604090819020805460ff191690555184908490808383808284376040519201829003822094507faee8df56d95b5766042c2ff4dcb39a120f0a09dd21bb9c143f86a314eff4b71493506000925050a250505050565b60075481565b6000805460010190819055610ce36128fb565b600160a060020a03166325ca4c9c336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b158015610d3b57600080fd5b505afa158015610d4f573d6000803e3d6000fd5b505050506040513d6020811015610d6557600080fd5b50511515610dab576040805160e560020a62461bcd02815260206004820152600f6024820152600080516020612f05833981519152604482015290519081900360640190fd5b33600090815260036020526040902060018101548310610e15576040805160e560020a62461bcd02815260206004820152601c60248201527f4261642070656e64696e67207769746864726177616c20696e64657800000000604482015290519081900360640190fd5b60008160010184815481101515610e2857fe5b9060005260206000209060020201905080600101544210151515610e96576040805160e560020a62461bcd02815260206004820181905260248201527f50656e64696e67207769746864726177616c206e6f7420617661696c61626c65604482015290519081900360640190fd5b8054610ea560018401866129ba565b604051339082156108fc029083906000818181858888f19350505050158015610ed2573d6000803e3d6000fd5b5060408051828152905133917f292d39ba701489b7f640c83806d3eeabe0a32c9f0a61b49e95612ebad42211cd919081900360200190a2505060005482149050610f54576040805160e560020a62461bcd02815260206004820152600e6024820152600080516020612e9b833981519152604482015290519081900360640190fd5b5050565b6000610fdb610f65612a2b565b600160a060020a0316639a0e7d666040518163ffffffff1660e060020a02815260040160206040518083038186803b158015610fa057600080fd5b505afa158015610fb4573d6000803e3d6000fd5b505050506040513d6020811015610fca57600080fd5b50516006549063ffffffff612ab916565b905090565b600160a060020a038116600090815260036020526040812054611095611004612a2b565b600160a060020a0316636c781a2c856040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b15801561105c57600080fd5b505afa158015611070573d6000803e3d6000fd5b505050506040513d602081101561108657600080fd5b5051829063ffffffff612ab916565b9392505050565b600254604080517f17c508180000000000000000000000000000000000000000000000000000000081523360248201819052600482019283526005805460448401819052600160a060020a03909516946317c5081894919382916064909101908590801561112957602002820191906000526020600020905b815481526020019060010190808311611115575b5050935050505060206040518083038186803b15801561114857600080fd5b505afa15801561115c573d6000803e3d6000fd5b505050506040513d602081101561117257600080fd5b505115156111b45760405160e560020a62461bcd028152600401808060200182810382526024815260200180612ebb6024913960400191505060405180910390fd5b60006111c88a6111c38d610fe0565b612b16565b905087811015611222576040805160e560020a62461bcd02815260206004820152601d60248201527f7265776172642063616e6e6f74206578636565642070656e616c74792e000000604482015290519081900360640190fd5b600160a060020a038b1660009081526003602052604081205490828210156113c357611254838363ffffffff612b2c16565b90508061125f612a2b565b600160a060020a0316638ef01def8f848d8d8d8d8d8d6040518963ffffffff1660e060020a0281526004018089600160a060020a0316600160a060020a0316815260200188815260200180602001806020018060200184810384528a8a82818152602001925060200280828437600083820152601f01601f19169091018581038452888152602090810191508990890280828437600083820152601f01601f19169091018581038352868152602090810191508790870280828437600081840152601f19601f8201169050808301925050509b505050505050505050505050602060405180830381600087803b15801561135857600080fd5b505af115801561136c573d6000803e3d6000fd5b505050506040513d602081101561138257600080fd5b5051146113c35760405160e560020a62461bcd028152600401808060200182810382526021815260200180612fbd6021913960400191505060405180910390fd5b6113dc8d6113d7858463ffffffff612b2c16565b61289f565b6113e68b8b612b6e565b5050600254604080517f476f7665726e616e6365000000000000000000000000000000000000000000006020808301919091528251808303600a018152602a830180855281519183019190912060e060020a63dcf0aaed02909152602e8301529151600093600160a060020a03169263dcf0aaed92604e8082019391829003018186803b15801561147657600080fd5b505afa15801561148a573d6000803e3d6000fd5b505050506040513d60208110156114a057600080fd5b5051905080600160a060020a0381166108fc6114c2858d63ffffffff612b2c16565b6040518115909202916000818181858888f193505050501580156114ea573d6000803e3d6000fd5b508a600160a060020a03168d600160a060020a03167f7abcb995a115c34a67528d58d5fc5ce02c22cb835ce1685046163f7d366d7111858d604051808381526020018281526020019250505060405180910390a350505050505050505050505050565b600160a060020a031660009081526003602052604090205490565b600254604080517f17c50818000000000000000000000000000000000000000000000000000000008152600160a060020a03848116602483015260048201928352600580546044840181905260009592909216936317c5081893919287928291606490910190859080156115fb57602002820191906000526020600020905b8154815260200190600101908083116115e7575b5050935050505060206040518083038186803b15801561161a57600080fd5b505afa15801561162e573d6000803e3d6000fd5b505050506040513d602081101561164457600080fd5b505192915050565b600080546001019081905561165f6128fb565b600160a060020a03166325ca4c9c336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b1580156116b757600080fd5b505afa1580156116cb573d6000803e3d6000fd5b505050506040513d60208110156116e157600080fd5b50511515611727576040805160e560020a62461bcd02815260206004820152600f6024820152600080516020612f05833981519152604482015290519081900360640190fd5b33600090815260036020526040902061173e612bc3565b600160a060020a0316635f8dd649336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b15801561179657600080fd5b505afa1580156117aa573d6000803e3d6000fd5b505050506040513d60208110156117c057600080fd5b505115611817576040805160e560020a62461bcd02815260206004820152600e60248201527f4163636f756e74206c6f636b6564000000000000000000000000000000000000604482015290519081900360640190fd5b6000611821612c51565b600160a060020a031663dcff4cf6336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b15801561187957600080fd5b505afa15801561188d573d6000803e3d6000fd5b505050506040513d60208110156118a357600080fd5b505190508015806118cc57506118c8846118bc33610fe0565b9063ffffffff612b2c16565b8111155b1515611922576040805160e560020a62461bcd02815260206004820152601e60248201527f547279696e6720746f20756e6c6f636b20746f6f206d75636820676f6c640000604482015290519081900360640190fd5b61192c338561289f565b600061194360075442612ab990919063ffffffff16565b60408051808201825287815260208082018481526001808901805480830182556000918252908490209451600290910290940193845590519201919091558151888152908101839052815192935033927fb1a3aef2a332070da206ad1868a5e327f5aa5144e00e9a7b40717c153158a588929181900390910190a2505060005482149050610f54576040805160e560020a62461bcd02815260206004820152600e6024820152600080516020612e9b833981519152604482015290519081900360640190fd5b611a11611f66565b1515611a55576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b60008282604051602001808383808284376040805191909301818103601f1901825280845281516020928301206002547fdd92723300000000000000000000000000000000000000000000000000000000835260048301829052945190985060009750600160a060020a03909416955063dd927233945060248082019492935090829003018186803b158015611aea57600080fd5b505afa158015611afe573d6000803e3d6000fd5b505050506040513d6020811015611b1457600080fd5b5051600160a060020a03161415611b75576040805160e560020a62461bcd02815260206004820152601c60248201527f4964656e746966696572206973206e6f74207265676973746572656400000000604482015290519081900360640190fd5b60008181526004602052604090205460ff1615611bdc576040805160e560020a62461bcd02815260206004820152601c60248201527f43616e6e6f742061646420736c61736865722049442074776963652e00000000604482015290519081900360640190fd5b6005805460018181019092557f036b6384b5eca791c62761152d0c79bb0604c104a5fb6f4eb0703f3154bb3db00182905560008281526004602052604090819020805460ff19169092179091555183908390808383808284376040519201829003822094507f92a16cb9e1846d175c3007fc61953d186452c9ea1aa34183eb4b7f88cd3f07bb93506000925050a2505050565b611c77611f66565b1515611cbb576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b600754811415611d15576040805160e560020a62461bcd02815260206004820152601c60248201527f556e6c6f636b696e6720706572696f64206e6f74206368616e67656400000000604482015290519081900360640190fd5b60078190556040805182815290517fd9274a7c98edc7c66931fc71872764091e7023fe3867358f8504d4c21b161fc59181900360200190a150565b6005805482908110611d5e57fe5b600091825260209091200154905081565b604080517f456c656374696f6e000000000000000000000000000000000000000000000000602080830191909152825160088184030181526028830180855281519183019190912060025460e060020a63dcf0aaed02909252602c840181905293513393600160a060020a039092169263dcf0aaed92604c8082019391829003018186803b158015611e0057600080fd5b505afa158015611e14573d6000803e3d6000fd5b505050506040513d6020811015611e2a57600080fd5b5051600160a060020a031614611e8a576040805160e560020a62461bcd02815260206004820152601860248201527f6f6e6c79207265676973746572656420636f6e74726163740000000000000000604482015290519081900360640190fd5b610a828383612b6e565b611e9c611f66565b1515611ee0576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b6001546040516000916101009004600160a060020a0316907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0908390a36001805474ffffffffffffffffffffffffffffffffffffffff0019169055565b600254600160a060020a031681565b60065490565b6001546101009004600160a060020a031690565b6001546000906101009004600160a060020a0316611f82612cdf565b600160a060020a031614905090565b611f99611f66565b1515611fdd576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b600160a060020a038116151561203d576040805160e560020a62461bcd02815260206004820181905260248201527f43616e6e6f7420726567697374657220746865206e756c6c2061646472657373604482015290519081900360640190fd5b6002805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0383169081179091556040517f27fe5f0c1c3b1ed427cc63d0f05759ffdecf9aec9e18d31ef366fc8a6cb5dc3b90600090a250565b60008054600101908190556120a76128fb565b600160a060020a03166325ca4c9c336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b1580156120ff57600080fd5b505afa158015612113573d6000803e3d6000fd5b505050506040513d602081101561212957600080fd5b5051151561216f576040805160e560020a62461bcd02815260206004820152600f6024820152600080516020612f05833981519152604482015290519081900360640190fd5b336000908152600360205260409020600181015484106121d9576040805160e560020a62461bcd02815260206004820152601c60248201527f4261642070656e64696e67207769746864726177616c20696e64657800000000604482015290519081900360640190fd5b600081600101858154811015156121ec57fe5b90600052602060002090600202019050806000015484111515156122445760405160e560020a62461bcd028152600401808060200182810382526029815260200180612f256029913960400191505060405180910390fd5b805484141561225f5761225a82600101866129ba565b612274565b8054612271908563ffffffff612b2c16565b81555b61227e3385612b6e565b60408051858152905133917fa823fc38a01c2f76d7057a79bb5c317710f26f7dbdea78634598d5519d0f7cb0919081900360200190a250506000548114610a82576040805160e560020a62461bcd02815260206004820152600e6024820152600080516020612e9b833981519152604482015290519081900360640190fd5b600160a060020a038116600090815260036020908152604080832060010180548251818502810185019093528083528493606093929190859084015b82821015612378576000848152602090819020604080518082019091526002850290910180548252600190810154828401529083529092019101612339565b509293506000925050505b81518110156123cf576123b5828281518110151561239d57fe5b6020908102909101015151849063ffffffff612ab916565b92506123c881600163ffffffff612ab916565b9050612383565b50909392505050565b60065481565b60015460ff1615612439576040805160e560020a62461bcd02815260206004820152601c60248201527f636f6e747261637420616c726561647920696e697469616c697a656400000000604482015290519081900360640190fd5b6001805460ff19168117905561244e33612ce3565b61245782611f91565b610f5481611c6f565b612468611f66565b15156124ac576040805160e560020a62461bcd0281526020600482018190526024820152600080516020612f9d833981519152604482015290519081900360640190fd5b6124b581612ce3565b50565b6060806124c36128fb565b600160a060020a03166325ca4c9c846040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b15801561251b57600080fd5b505afa15801561252f573d6000803e3d6000fd5b505050506040513d602081101561254557600080fd5b5051151561258b576040805160e560020a62461bcd02815260206004820152600f6024820152600080516020612f05833981519152604482015290519081900360640190fd5b600160a060020a03831660009081526003602090815260409182902060010154825181815281830281019092019092526060908280156125d5578160200160208202803883390190505b509050606082604051908082528060200260200182016040528015612604578160200160208202803883390190505b50905060005b838110156126c75761261a612e3b565b600160a060020a038816600090815260036020526040902060010180548390811061264157fe5b90600052602060002090600202016040805190810160405290816000820154815260200160018201548152505090508060000151848381518110151561268357fe5b9060200190602002018181525050806020015183838151811015156126a457fe5b60209081029091010152506126c081600163ffffffff612ab916565b905061260a565b50909350915050915091565b60008054600101908190556126e66128fb565b600160a060020a03166325ca4c9c336040518263ffffffff1660e060020a0281526004018082600160a060020a0316600160a060020a0316815260200191505060206040518083038186803b15801561273e57600080fd5b505afa158015612752573d6000803e3d6000fd5b505050506040513d602081101561276857600080fd5b505115156127c0576040805160e560020a62461bcd02815260206004820152600b60248201527f6e6f74206163636f756e74000000000000000000000000000000000000000000604482015290519081900360640190fd5b60003411612818576040805160e560020a62461bcd02815260206004820152600860248201527f6e6f2076616c7565000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6128223334612b6e565b60408051348152905133917f0f0f2fc5b4c987a49e1663ce2c2d65de12f3b701ff02b4d09461421e63e609e7919081900360200190a260005481146124b5576040805160e560020a62461bcd02815260206004820152600e6024820152600080516020612e9b833981519152604482015290519081900360640190fd5b600160a060020a0382166000908152600360205260409020546128c8908263ffffffff612b2c16565b600160a060020a0383166000908152600360205260409020556006546128f4908263ffffffff612b2c16565b6006555050565b600254604080517f4163636f756e7473000000000000000000000000000000000000000000000000602080830191909152825180830360080181526028830180855281519183019190912060e060020a63dcf0aaed02909152602c8301529151600093600160a060020a03169263dcf0aaed92604c8082019391829003018186803b15801561298957600080fd5b505afa15801561299d573d6000803e3d6000fd5b505050506040513d60208110156129b357600080fd5b5051905090565b81546000906129d090600163ffffffff612b2c16565b905082818154811015156129e057fe5b906000526020600020906002020183838154811015156129fc57fe5b60009182526020909120825460029092020190815560019182015491015580612a258482612e52565b50505050565b600254604080517f456c656374696f6e000000000000000000000000000000000000000000000000602080830191909152825180830360080181526028830180855281519183019190912060e060020a63dcf0aaed02909152602c8301529151600093600160a060020a03169263dcf0aaed92604c8082019391829003018186803b15801561298957600080fd5b600082820183811015611095576040805160e560020a62461bcd02815260206004820152601b60248201527f536166654d6174683a206164646974696f6e206f766572666c6f770000000000604482015290519081900360640190fd5b6000818310612b255781611095565b5090919050565b600061109583836040805190810160405280601e81526020017f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815250612da1565b600160a060020a038216600090815260036020526040902054612b97908263ffffffff612ab916565b600160a060020a0383166000908152600360205260409020556006546128f4908263ffffffff612ab916565b600254604080517f476f7665726e616e6365000000000000000000000000000000000000000000006020808301919091528251808303600a018152602a830180855281519183019190912060e060020a63dcf0aaed02909152602e8301529151600093600160a060020a03169263dcf0aaed92604e8082019391829003018186803b15801561298957600080fd5b600254604080517f56616c696461746f7273000000000000000000000000000000000000000000006020808301919091528251808303600a018152602a830180855281519183019190912060e060020a63dcf0aaed02909152602e8301529151600093600160a060020a03169263dcf0aaed92604e8082019391829003018186803b15801561298957600080fd5b3390565b600160a060020a0381161515612d2d5760405160e560020a62461bcd028152600401808060200182810382526026815260200180612edf6026913960400191505060405180910390fd5b600154604051600160a060020a0380841692610100900416907f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e090600090a360018054600160a060020a039092166101000274ffffffffffffffffffffffffffffffffffffffff0019909216919091179055565b60008184841115612e335760405160e560020a62461bcd0281526004018080602001828103825283818151815260200191508051906020019080838360005b83811015612df8578181015183820152602001612de0565b50505050905090810190601f168015612e255780820380516001836020036101000a031916815260200191505b509250505060405180910390fd5b505050900390565b604080518082019091526000808252602082015290565b815481835581811115610a8257600083815260209020610a82916109519160029182028101918502015b80821115612e965760008082556001820155600201612e7c565b509056fe7265656e7472616e742063616c6c00000000000000000000000000000000000043616c6c6572206973206e6f7420612077686974656c697374656420736c61736865722e4f776e61626c653a206e6577206f776e657220697320746865207a65726f2061646472657373556e6b6e6f776e206163636f756e7400000000000000000000000000000000005265717565737465642076616c7565206c6172676572207468616e2070656e64696e672076616c756550726f766964656420696e64657820657863656564732077686974656c69737420626f756e64732e43616e6e6f742072656d6f766520736c6173686572204944206e6f74207965742061646465642e4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657243616e6e6f74207265766f6b6520656e6f75676820766f74696e6720676f6c642ea165627a7a7230582069adbb52806b327d6e95637a51e0a8a35f0c8e4e93f44060c4129ff0b5e166090029"

// DeployLockedGold deploys a new Ethereum contract, binding an instance of LockedGold to it.
func DeployLockedGold(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *LockedGold, error) {
	parsed, err := abi.JSON(strings.NewReader(LockedGoldABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(LockedGoldBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &LockedGold{LockedGoldCaller: LockedGoldCaller{contract: contract}, LockedGoldTransactor: LockedGoldTransactor{contract: contract}, LockedGoldFilterer: LockedGoldFilterer{contract: contract}}, nil
}

// LockedGold is an auto generated Go binding around an Ethereum contract.
type LockedGold struct {
	LockedGoldCaller     // Read-only binding to the contract
	LockedGoldTransactor // Write-only binding to the contract
	LockedGoldFilterer   // Log filterer for contract events
}

// LockedGoldCaller is an auto generated read-only Go binding around an Ethereum contract.
type LockedGoldCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LockedGoldTransactor is an auto generated write-only Go binding around an Ethereum contract.
type LockedGoldTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LockedGoldFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type LockedGoldFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// LockedGoldSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type LockedGoldSession struct {
	Contract     *LockedGold       // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// LockedGoldCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type LockedGoldCallerSession struct {
	Contract *LockedGoldCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts     // Call options to use throughout this session
}

// LockedGoldTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type LockedGoldTransactorSession struct {
	Contract     *LockedGoldTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts     // Transaction auth options to use throughout this session
}

// LockedGoldRaw is an auto generated low-level Go binding around an Ethereum contract.
type LockedGoldRaw struct {
	Contract *LockedGold // Generic contract binding to access the raw methods on
}

// LockedGoldCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type LockedGoldCallerRaw struct {
	Contract *LockedGoldCaller // Generic read-only contract binding to access the raw methods on
}

// LockedGoldTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type LockedGoldTransactorRaw struct {
	Contract *LockedGoldTransactor // Generic write-only contract binding to access the raw methods on
}

// NewLockedGold creates a new instance of LockedGold, bound to a specific deployed contract.
func NewLockedGold(address common.Address, backend bind.ContractBackend) (*LockedGold, error) {
	contract, err := bindLockedGold(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &LockedGold{LockedGoldCaller: LockedGoldCaller{contract: contract}, LockedGoldTransactor: LockedGoldTransactor{contract: contract}, LockedGoldFilterer: LockedGoldFilterer{contract: contract}}, nil
}

// NewLockedGoldCaller creates a new read-only instance of LockedGold, bound to a specific deployed contract.
func NewLockedGoldCaller(address common.Address, caller bind.ContractCaller) (*LockedGoldCaller, error) {
	contract, err := bindLockedGold(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &LockedGoldCaller{contract: contract}, nil
}

// NewLockedGoldTransactor creates a new write-only instance of LockedGold, bound to a specific deployed contract.
func NewLockedGoldTransactor(address common.Address, transactor bind.ContractTransactor) (*LockedGoldTransactor, error) {
	contract, err := bindLockedGold(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &LockedGoldTransactor{contract: contract}, nil
}

// NewLockedGoldFilterer creates a new log filterer instance of LockedGold, bound to a specific deployed contract.
func NewLockedGoldFilterer(address common.Address, filterer bind.ContractFilterer) (*LockedGoldFilterer, error) {
	contract, err := bindLockedGold(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &LockedGoldFilterer{contract: contract}, nil
}

// bindLockedGold binds a generic wrapper to an already deployed contract.
func bindLockedGold(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(LockedGoldABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LockedGold *LockedGoldRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _LockedGold.Contract.LockedGoldCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LockedGold *LockedGoldRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LockedGold.Contract.LockedGoldTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LockedGold *LockedGoldRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LockedGold.Contract.LockedGoldTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_LockedGold *LockedGoldCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _LockedGold.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_LockedGold *LockedGoldTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LockedGold.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_LockedGold *LockedGoldTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _LockedGold.Contract.contract.Transact(opts, method, params...)
}

// GetAccountNonvotingLockedGold is a free data retrieval call binding the contract method 0x3f199b40.
//
// Solidity: function getAccountNonvotingLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCaller) GetAccountNonvotingLockedGold(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getAccountNonvotingLockedGold", account)
	return *ret0, err
}

// GetAccountNonvotingLockedGold is a free data retrieval call binding the contract method 0x3f199b40.
//
// Solidity: function getAccountNonvotingLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldSession) GetAccountNonvotingLockedGold(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetAccountNonvotingLockedGold(&_LockedGold.CallOpts, account)
}

// GetAccountNonvotingLockedGold is a free data retrieval call binding the contract method 0x3f199b40.
//
// Solidity: function getAccountNonvotingLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) GetAccountNonvotingLockedGold(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetAccountNonvotingLockedGold(&_LockedGold.CallOpts, account)
}

// GetAccountTotalLockedGold is a free data retrieval call binding the contract method 0x30ec70f5.
//
// Solidity: function getAccountTotalLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCaller) GetAccountTotalLockedGold(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getAccountTotalLockedGold", account)
	return *ret0, err
}

// GetAccountTotalLockedGold is a free data retrieval call binding the contract method 0x30ec70f5.
//
// Solidity: function getAccountTotalLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldSession) GetAccountTotalLockedGold(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetAccountTotalLockedGold(&_LockedGold.CallOpts, account)
}

// GetAccountTotalLockedGold is a free data retrieval call binding the contract method 0x30ec70f5.
//
// Solidity: function getAccountTotalLockedGold(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) GetAccountTotalLockedGold(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetAccountTotalLockedGold(&_LockedGold.CallOpts, account)
}

// GetNonvotingLockedGold is a free data retrieval call binding the contract method 0x807876b7.
//
// Solidity: function getNonvotingLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldCaller) GetNonvotingLockedGold(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getNonvotingLockedGold")
	return *ret0, err
}

// GetNonvotingLockedGold is a free data retrieval call binding the contract method 0x807876b7.
//
// Solidity: function getNonvotingLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldSession) GetNonvotingLockedGold() (*big.Int, error) {
	return _LockedGold.Contract.GetNonvotingLockedGold(&_LockedGold.CallOpts)
}

// GetNonvotingLockedGold is a free data retrieval call binding the contract method 0x807876b7.
//
// Solidity: function getNonvotingLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) GetNonvotingLockedGold() (*big.Int, error) {
	return _LockedGold.Contract.GetNonvotingLockedGold(&_LockedGold.CallOpts)
}

// GetPendingWithdrawals is a free data retrieval call binding the contract method 0xf340c0d0.
//
// Solidity: function getPendingWithdrawals(address account) constant returns(uint256[], uint256[])
func (_LockedGold *LockedGoldCaller) GetPendingWithdrawals(opts *bind.CallOpts, account common.Address) ([]*big.Int, []*big.Int, error) {
	var (
		ret0 = new([]*big.Int)
		ret1 = new([]*big.Int)
	)
	out := &[]interface{}{
		ret0,
		ret1,
	}
	err := _LockedGold.contract.Call(opts, out, "getPendingWithdrawals", account)
	return *ret0, *ret1, err
}

// GetPendingWithdrawals is a free data retrieval call binding the contract method 0xf340c0d0.
//
// Solidity: function getPendingWithdrawals(address account) constant returns(uint256[], uint256[])
func (_LockedGold *LockedGoldSession) GetPendingWithdrawals(account common.Address) ([]*big.Int, []*big.Int, error) {
	return _LockedGold.Contract.GetPendingWithdrawals(&_LockedGold.CallOpts, account)
}

// GetPendingWithdrawals is a free data retrieval call binding the contract method 0xf340c0d0.
//
// Solidity: function getPendingWithdrawals(address account) constant returns(uint256[], uint256[])
func (_LockedGold *LockedGoldCallerSession) GetPendingWithdrawals(account common.Address) ([]*big.Int, []*big.Int, error) {
	return _LockedGold.Contract.GetPendingWithdrawals(&_LockedGold.CallOpts, account)
}

// GetSlashingWhitelist is a free data retrieval call binding the contract method 0x08764ee2.
//
// Solidity: function getSlashingWhitelist() constant returns(bytes32[])
func (_LockedGold *LockedGoldCaller) GetSlashingWhitelist(opts *bind.CallOpts) ([][32]byte, error) {
	var (
		ret0 = new([][32]byte)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getSlashingWhitelist")
	return *ret0, err
}

// GetSlashingWhitelist is a free data retrieval call binding the contract method 0x08764ee2.
//
// Solidity: function getSlashingWhitelist() constant returns(bytes32[])
func (_LockedGold *LockedGoldSession) GetSlashingWhitelist() ([][32]byte, error) {
	return _LockedGold.Contract.GetSlashingWhitelist(&_LockedGold.CallOpts)
}

// GetSlashingWhitelist is a free data retrieval call binding the contract method 0x08764ee2.
//
// Solidity: function getSlashingWhitelist() constant returns(bytes32[])
func (_LockedGold *LockedGoldCallerSession) GetSlashingWhitelist() ([][32]byte, error) {
	return _LockedGold.Contract.GetSlashingWhitelist(&_LockedGold.CallOpts)
}

// GetTotalLockedGold is a free data retrieval call binding the contract method 0x30a61d59.
//
// Solidity: function getTotalLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldCaller) GetTotalLockedGold(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getTotalLockedGold")
	return *ret0, err
}

// GetTotalLockedGold is a free data retrieval call binding the contract method 0x30a61d59.
//
// Solidity: function getTotalLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldSession) GetTotalLockedGold() (*big.Int, error) {
	return _LockedGold.Contract.GetTotalLockedGold(&_LockedGold.CallOpts)
}

// GetTotalLockedGold is a free data retrieval call binding the contract method 0x30a61d59.
//
// Solidity: function getTotalLockedGold() constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) GetTotalLockedGold() (*big.Int, error) {
	return _LockedGold.Contract.GetTotalLockedGold(&_LockedGold.CallOpts)
}

// GetTotalPendingWithdrawals is a free data retrieval call binding the contract method 0xb6e1e49d.
//
// Solidity: function getTotalPendingWithdrawals(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCaller) GetTotalPendingWithdrawals(opts *bind.CallOpts, account common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "getTotalPendingWithdrawals", account)
	return *ret0, err
}

// GetTotalPendingWithdrawals is a free data retrieval call binding the contract method 0xb6e1e49d.
//
// Solidity: function getTotalPendingWithdrawals(address account) constant returns(uint256)
func (_LockedGold *LockedGoldSession) GetTotalPendingWithdrawals(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetTotalPendingWithdrawals(&_LockedGold.CallOpts, account)
}

// GetTotalPendingWithdrawals is a free data retrieval call binding the contract method 0xb6e1e49d.
//
// Solidity: function getTotalPendingWithdrawals(address account) constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) GetTotalPendingWithdrawals(account common.Address) (*big.Int, error) {
	return _LockedGold.Contract.GetTotalPendingWithdrawals(&_LockedGold.CallOpts, account)
}

// Initialized is a free data retrieval call binding the contract method 0x158ef93e.
//
// Solidity: function initialized() constant returns(bool)
func (_LockedGold *LockedGoldCaller) Initialized(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "initialized")
	return *ret0, err
}

// Initialized is a free data retrieval call binding the contract method 0x158ef93e.
//
// Solidity: function initialized() constant returns(bool)
func (_LockedGold *LockedGoldSession) Initialized() (bool, error) {
	return _LockedGold.Contract.Initialized(&_LockedGold.CallOpts)
}

// Initialized is a free data retrieval call binding the contract method 0x158ef93e.
//
// Solidity: function initialized() constant returns(bool)
func (_LockedGold *LockedGoldCallerSession) Initialized() (bool, error) {
	return _LockedGold.Contract.Initialized(&_LockedGold.CallOpts)
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_LockedGold *LockedGoldCaller) IsOwner(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "isOwner")
	return *ret0, err
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_LockedGold *LockedGoldSession) IsOwner() (bool, error) {
	return _LockedGold.Contract.IsOwner(&_LockedGold.CallOpts)
}

// IsOwner is a free data retrieval call binding the contract method 0x8f32d59b.
//
// Solidity: function isOwner() constant returns(bool)
func (_LockedGold *LockedGoldCallerSession) IsOwner() (bool, error) {
	return _LockedGold.Contract.IsOwner(&_LockedGold.CallOpts)
}

// IsSlasher is a free data retrieval call binding the contract method 0x57601c5d.
//
// Solidity: function isSlasher(address slasher) constant returns(bool)
func (_LockedGold *LockedGoldCaller) IsSlasher(opts *bind.CallOpts, slasher common.Address) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "isSlasher", slasher)
	return *ret0, err
}

// IsSlasher is a free data retrieval call binding the contract method 0x57601c5d.
//
// Solidity: function isSlasher(address slasher) constant returns(bool)
func (_LockedGold *LockedGoldSession) IsSlasher(slasher common.Address) (bool, error) {
	return _LockedGold.Contract.IsSlasher(&_LockedGold.CallOpts, slasher)
}

// IsSlasher is a free data retrieval call binding the contract method 0x57601c5d.
//
// Solidity: function isSlasher(address slasher) constant returns(bool)
func (_LockedGold *LockedGoldCallerSession) IsSlasher(slasher common.Address) (bool, error) {
	return _LockedGold.Contract.IsSlasher(&_LockedGold.CallOpts, slasher)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_LockedGold *LockedGoldCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_LockedGold *LockedGoldSession) Owner() (common.Address, error) {
	return _LockedGold.Contract.Owner(&_LockedGold.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_LockedGold *LockedGoldCallerSession) Owner() (common.Address, error) {
	return _LockedGold.Contract.Owner(&_LockedGold.CallOpts)
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() constant returns(address)
func (_LockedGold *LockedGoldCaller) Registry(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "registry")
	return *ret0, err
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() constant returns(address)
func (_LockedGold *LockedGoldSession) Registry() (common.Address, error) {
	return _LockedGold.Contract.Registry(&_LockedGold.CallOpts)
}

// Registry is a free data retrieval call binding the contract method 0x7b103999.
//
// Solidity: function registry() constant returns(address)
func (_LockedGold *LockedGoldCallerSession) Registry() (common.Address, error) {
	return _LockedGold.Contract.Registry(&_LockedGold.CallOpts)
}

// SlashingWhitelist is a free data retrieval call binding the contract method 0x6adcc938.
//
// Solidity: function slashingWhitelist(uint256 ) constant returns(bytes32)
func (_LockedGold *LockedGoldCaller) SlashingWhitelist(opts *bind.CallOpts, arg0 *big.Int) ([32]byte, error) {
	var (
		ret0 = new([32]byte)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "slashingWhitelist", arg0)
	return *ret0, err
}

// SlashingWhitelist is a free data retrieval call binding the contract method 0x6adcc938.
//
// Solidity: function slashingWhitelist(uint256 ) constant returns(bytes32)
func (_LockedGold *LockedGoldSession) SlashingWhitelist(arg0 *big.Int) ([32]byte, error) {
	return _LockedGold.Contract.SlashingWhitelist(&_LockedGold.CallOpts, arg0)
}

// SlashingWhitelist is a free data retrieval call binding the contract method 0x6adcc938.
//
// Solidity: function slashingWhitelist(uint256 ) constant returns(bytes32)
func (_LockedGold *LockedGoldCallerSession) SlashingWhitelist(arg0 *big.Int) ([32]byte, error) {
	return _LockedGold.Contract.SlashingWhitelist(&_LockedGold.CallOpts, arg0)
}

// TotalNonvoting is a free data retrieval call binding the contract method 0xc1867f6d.
//
// Solidity: function totalNonvoting() constant returns(uint256)
func (_LockedGold *LockedGoldCaller) TotalNonvoting(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "totalNonvoting")
	return *ret0, err
}

// TotalNonvoting is a free data retrieval call binding the contract method 0xc1867f6d.
//
// Solidity: function totalNonvoting() constant returns(uint256)
func (_LockedGold *LockedGoldSession) TotalNonvoting() (*big.Int, error) {
	return _LockedGold.Contract.TotalNonvoting(&_LockedGold.CallOpts)
}

// TotalNonvoting is a free data retrieval call binding the contract method 0xc1867f6d.
//
// Solidity: function totalNonvoting() constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) TotalNonvoting() (*big.Int, error) {
	return _LockedGold.Contract.TotalNonvoting(&_LockedGold.CallOpts)
}

// UnlockingPeriod is a free data retrieval call binding the contract method 0x20637d8e.
//
// Solidity: function unlockingPeriod() constant returns(uint256)
func (_LockedGold *LockedGoldCaller) UnlockingPeriod(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _LockedGold.contract.Call(opts, out, "unlockingPeriod")
	return *ret0, err
}

// UnlockingPeriod is a free data retrieval call binding the contract method 0x20637d8e.
//
// Solidity: function unlockingPeriod() constant returns(uint256)
func (_LockedGold *LockedGoldSession) UnlockingPeriod() (*big.Int, error) {
	return _LockedGold.Contract.UnlockingPeriod(&_LockedGold.CallOpts)
}

// UnlockingPeriod is a free data retrieval call binding the contract method 0x20637d8e.
//
// Solidity: function unlockingPeriod() constant returns(uint256)
func (_LockedGold *LockedGoldCallerSession) UnlockingPeriod() (*big.Int, error) {
	return _LockedGold.Contract.UnlockingPeriod(&_LockedGold.CallOpts)
}

// AddSlasher is a paid mutator transaction binding the contract method 0x64891198.
//
// Solidity: function addSlasher(string slasherIdentifier) returns()
func (_LockedGold *LockedGoldTransactor) AddSlasher(opts *bind.TransactOpts, slasherIdentifier string) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "addSlasher", slasherIdentifier)
}

// AddSlasher is a paid mutator transaction binding the contract method 0x64891198.
//
// Solidity: function addSlasher(string slasherIdentifier) returns()
func (_LockedGold *LockedGoldSession) AddSlasher(slasherIdentifier string) (*types.Transaction, error) {
	return _LockedGold.Contract.AddSlasher(&_LockedGold.TransactOpts, slasherIdentifier)
}

// AddSlasher is a paid mutator transaction binding the contract method 0x64891198.
//
// Solidity: function addSlasher(string slasherIdentifier) returns()
func (_LockedGold *LockedGoldTransactorSession) AddSlasher(slasherIdentifier string) (*types.Transaction, error) {
	return _LockedGold.Contract.AddSlasher(&_LockedGold.TransactOpts, slasherIdentifier)
}

// DecrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x18a4ff8c.
//
// Solidity: function decrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldTransactor) DecrementNonvotingAccountBalance(opts *bind.TransactOpts, account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "decrementNonvotingAccountBalance", account, value)
}

// DecrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x18a4ff8c.
//
// Solidity: function decrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldSession) DecrementNonvotingAccountBalance(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.DecrementNonvotingAccountBalance(&_LockedGold.TransactOpts, account, value)
}

// DecrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x18a4ff8c.
//
// Solidity: function decrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldTransactorSession) DecrementNonvotingAccountBalance(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.DecrementNonvotingAccountBalance(&_LockedGold.TransactOpts, account, value)
}

// IncrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x6edf77a5.
//
// Solidity: function incrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldTransactor) IncrementNonvotingAccountBalance(opts *bind.TransactOpts, account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "incrementNonvotingAccountBalance", account, value)
}

// IncrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x6edf77a5.
//
// Solidity: function incrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldSession) IncrementNonvotingAccountBalance(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.IncrementNonvotingAccountBalance(&_LockedGold.TransactOpts, account, value)
}

// IncrementNonvotingAccountBalance is a paid mutator transaction binding the contract method 0x6edf77a5.
//
// Solidity: function incrementNonvotingAccountBalance(address account, uint256 value) returns()
func (_LockedGold *LockedGoldTransactorSession) IncrementNonvotingAccountBalance(account common.Address, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.IncrementNonvotingAccountBalance(&_LockedGold.TransactOpts, account, value)
}

// Initialize is a paid mutator transaction binding the contract method 0xcd6dc687.
//
// Solidity: function initialize(address registryAddress, uint256 _unlockingPeriod) returns()
func (_LockedGold *LockedGoldTransactor) Initialize(opts *bind.TransactOpts, registryAddress common.Address, _unlockingPeriod *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "initialize", registryAddress, _unlockingPeriod)
}

// Initialize is a paid mutator transaction binding the contract method 0xcd6dc687.
//
// Solidity: function initialize(address registryAddress, uint256 _unlockingPeriod) returns()
func (_LockedGold *LockedGoldSession) Initialize(registryAddress common.Address, _unlockingPeriod *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Initialize(&_LockedGold.TransactOpts, registryAddress, _unlockingPeriod)
}

// Initialize is a paid mutator transaction binding the contract method 0xcd6dc687.
//
// Solidity: function initialize(address registryAddress, uint256 _unlockingPeriod) returns()
func (_LockedGold *LockedGoldTransactorSession) Initialize(registryAddress common.Address, _unlockingPeriod *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Initialize(&_LockedGold.TransactOpts, registryAddress, _unlockingPeriod)
}

// Lock is a paid mutator transaction binding the contract method 0xf83d08ba.
//
// Solidity: function lock() returns()
func (_LockedGold *LockedGoldTransactor) Lock(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "lock")
}

// Lock is a paid mutator transaction binding the contract method 0xf83d08ba.
//
// Solidity: function lock() returns()
func (_LockedGold *LockedGoldSession) Lock() (*types.Transaction, error) {
	return _LockedGold.Contract.Lock(&_LockedGold.TransactOpts)
}

// Lock is a paid mutator transaction binding the contract method 0xf83d08ba.
//
// Solidity: function lock() returns()
func (_LockedGold *LockedGoldTransactorSession) Lock() (*types.Transaction, error) {
	return _LockedGold.Contract.Lock(&_LockedGold.TransactOpts)
}

// Relock is a paid mutator transaction binding the contract method 0xb2fb30cb.
//
// Solidity: function relock(uint256 index, uint256 value) returns()
func (_LockedGold *LockedGoldTransactor) Relock(opts *bind.TransactOpts, index *big.Int, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "relock", index, value)
}

// Relock is a paid mutator transaction binding the contract method 0xb2fb30cb.
//
// Solidity: function relock(uint256 index, uint256 value) returns()
func (_LockedGold *LockedGoldSession) Relock(index *big.Int, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Relock(&_LockedGold.TransactOpts, index, value)
}

// Relock is a paid mutator transaction binding the contract method 0xb2fb30cb.
//
// Solidity: function relock(uint256 index, uint256 value) returns()
func (_LockedGold *LockedGoldTransactorSession) Relock(index *big.Int, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Relock(&_LockedGold.TransactOpts, index, value)
}

// RemoveSlasher is a paid mutator transaction binding the contract method 0x1fe2dfda.
//
// Solidity: function removeSlasher(string slasherIdentifier, uint256 index) returns()
func (_LockedGold *LockedGoldTransactor) RemoveSlasher(opts *bind.TransactOpts, slasherIdentifier string, index *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "removeSlasher", slasherIdentifier, index)
}

// RemoveSlasher is a paid mutator transaction binding the contract method 0x1fe2dfda.
//
// Solidity: function removeSlasher(string slasherIdentifier, uint256 index) returns()
func (_LockedGold *LockedGoldSession) RemoveSlasher(slasherIdentifier string, index *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.RemoveSlasher(&_LockedGold.TransactOpts, slasherIdentifier, index)
}

// RemoveSlasher is a paid mutator transaction binding the contract method 0x1fe2dfda.
//
// Solidity: function removeSlasher(string slasherIdentifier, uint256 index) returns()
func (_LockedGold *LockedGoldTransactorSession) RemoveSlasher(slasherIdentifier string, index *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.RemoveSlasher(&_LockedGold.TransactOpts, slasherIdentifier, index)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_LockedGold *LockedGoldTransactor) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "renounceOwnership")
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_LockedGold *LockedGoldSession) RenounceOwnership() (*types.Transaction, error) {
	return _LockedGold.Contract.RenounceOwnership(&_LockedGold.TransactOpts)
}

// RenounceOwnership is a paid mutator transaction binding the contract method 0x715018a6.
//
// Solidity: function renounceOwnership() returns()
func (_LockedGold *LockedGoldTransactorSession) RenounceOwnership() (*types.Transaction, error) {
	return _LockedGold.Contract.RenounceOwnership(&_LockedGold.TransactOpts)
}

// SetRegistry is a paid mutator transaction binding the contract method 0xa91ee0dc.
//
// Solidity: function setRegistry(address registryAddress) returns()
func (_LockedGold *LockedGoldTransactor) SetRegistry(opts *bind.TransactOpts, registryAddress common.Address) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "setRegistry", registryAddress)
}

// SetRegistry is a paid mutator transaction binding the contract method 0xa91ee0dc.
//
// Solidity: function setRegistry(address registryAddress) returns()
func (_LockedGold *LockedGoldSession) SetRegistry(registryAddress common.Address) (*types.Transaction, error) {
	return _LockedGold.Contract.SetRegistry(&_LockedGold.TransactOpts, registryAddress)
}

// SetRegistry is a paid mutator transaction binding the contract method 0xa91ee0dc.
//
// Solidity: function setRegistry(address registryAddress) returns()
func (_LockedGold *LockedGoldTransactorSession) SetRegistry(registryAddress common.Address) (*types.Transaction, error) {
	return _LockedGold.Contract.SetRegistry(&_LockedGold.TransactOpts, registryAddress)
}

// SetUnlockingPeriod is a paid mutator transaction binding the contract method 0x66f0633b.
//
// Solidity: function setUnlockingPeriod(uint256 value) returns()
func (_LockedGold *LockedGoldTransactor) SetUnlockingPeriod(opts *bind.TransactOpts, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "setUnlockingPeriod", value)
}

// SetUnlockingPeriod is a paid mutator transaction binding the contract method 0x66f0633b.
//
// Solidity: function setUnlockingPeriod(uint256 value) returns()
func (_LockedGold *LockedGoldSession) SetUnlockingPeriod(value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.SetUnlockingPeriod(&_LockedGold.TransactOpts, value)
}

// SetUnlockingPeriod is a paid mutator transaction binding the contract method 0x66f0633b.
//
// Solidity: function setUnlockingPeriod(uint256 value) returns()
func (_LockedGold *LockedGoldTransactorSession) SetUnlockingPeriod(value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.SetUnlockingPeriod(&_LockedGold.TransactOpts, value)
}

// Slash is a paid mutator transaction binding the contract method 0x31993fc9.
//
// Solidity: function slash(address account, uint256 penalty, address reporter, uint256 reward, address[] lessers, address[] greaters, uint256[] indices) returns()
func (_LockedGold *LockedGoldTransactor) Slash(opts *bind.TransactOpts, account common.Address, penalty *big.Int, reporter common.Address, reward *big.Int, lessers []common.Address, greaters []common.Address, indices []*big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "slash", account, penalty, reporter, reward, lessers, greaters, indices)
}

// Slash is a paid mutator transaction binding the contract method 0x31993fc9.
//
// Solidity: function slash(address account, uint256 penalty, address reporter, uint256 reward, address[] lessers, address[] greaters, uint256[] indices) returns()
func (_LockedGold *LockedGoldSession) Slash(account common.Address, penalty *big.Int, reporter common.Address, reward *big.Int, lessers []common.Address, greaters []common.Address, indices []*big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Slash(&_LockedGold.TransactOpts, account, penalty, reporter, reward, lessers, greaters, indices)
}

// Slash is a paid mutator transaction binding the contract method 0x31993fc9.
//
// Solidity: function slash(address account, uint256 penalty, address reporter, uint256 reward, address[] lessers, address[] greaters, uint256[] indices) returns()
func (_LockedGold *LockedGoldTransactorSession) Slash(account common.Address, penalty *big.Int, reporter common.Address, reward *big.Int, lessers []common.Address, greaters []common.Address, indices []*big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Slash(&_LockedGold.TransactOpts, account, penalty, reporter, reward, lessers, greaters, indices)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_LockedGold *LockedGoldTransactor) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "transferOwnership", newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_LockedGold *LockedGoldSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _LockedGold.Contract.TransferOwnership(&_LockedGold.TransactOpts, newOwner)
}

// TransferOwnership is a paid mutator transaction binding the contract method 0xf2fde38b.
//
// Solidity: function transferOwnership(address newOwner) returns()
func (_LockedGold *LockedGoldTransactorSession) TransferOwnership(newOwner common.Address) (*types.Transaction, error) {
	return _LockedGold.Contract.TransferOwnership(&_LockedGold.TransactOpts, newOwner)
}

// Unlock is a paid mutator transaction binding the contract method 0x6198e339.
//
// Solidity: function unlock(uint256 value) returns()
func (_LockedGold *LockedGoldTransactor) Unlock(opts *bind.TransactOpts, value *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "unlock", value)
}

// Unlock is a paid mutator transaction binding the contract method 0x6198e339.
//
// Solidity: function unlock(uint256 value) returns()
func (_LockedGold *LockedGoldSession) Unlock(value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Unlock(&_LockedGold.TransactOpts, value)
}

// Unlock is a paid mutator transaction binding the contract method 0x6198e339.
//
// Solidity: function unlock(uint256 value) returns()
func (_LockedGold *LockedGoldTransactorSession) Unlock(value *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Unlock(&_LockedGold.TransactOpts, value)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 index) returns()
func (_LockedGold *LockedGoldTransactor) Withdraw(opts *bind.TransactOpts, index *big.Int) (*types.Transaction, error) {
	return _LockedGold.contract.Transact(opts, "withdraw", index)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 index) returns()
func (_LockedGold *LockedGoldSession) Withdraw(index *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Withdraw(&_LockedGold.TransactOpts, index)
}

// Withdraw is a paid mutator transaction binding the contract method 0x2e1a7d4d.
//
// Solidity: function withdraw(uint256 index) returns()
func (_LockedGold *LockedGoldTransactorSession) Withdraw(index *big.Int) (*types.Transaction, error) {
	return _LockedGold.Contract.Withdraw(&_LockedGold.TransactOpts, index)
}

// LockedGoldAccountSlashedIterator is returned from FilterAccountSlashed and is used to iterate over the raw logs and unpacked data for AccountSlashed events raised by the LockedGold contract.
type LockedGoldAccountSlashedIterator struct {
	Event *LockedGoldAccountSlashed // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldAccountSlashedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldAccountSlashed)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldAccountSlashed)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldAccountSlashedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldAccountSlashedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldAccountSlashed represents a AccountSlashed event raised by the LockedGold contract.
type LockedGoldAccountSlashed struct {
	Slashed  common.Address
	Penalty  *big.Int
	Reporter common.Address
	Reward   *big.Int
	Raw      types.Log // Blockchain specific contextual infos
}

// FilterAccountSlashed is a free log retrieval operation binding the contract event 0x7abcb995a115c34a67528d58d5fc5ce02c22cb835ce1685046163f7d366d7111.
//
// Solidity: event AccountSlashed(address indexed slashed, uint256 penalty, address indexed reporter, uint256 reward)
func (_LockedGold *LockedGoldFilterer) FilterAccountSlashed(opts *bind.FilterOpts, slashed []common.Address, reporter []common.Address) (*LockedGoldAccountSlashedIterator, error) {

	var slashedRule []interface{}
	for _, slashedItem := range slashed {
		slashedRule = append(slashedRule, slashedItem)
	}

	var reporterRule []interface{}
	for _, reporterItem := range reporter {
		reporterRule = append(reporterRule, reporterItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "AccountSlashed", slashedRule, reporterRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldAccountSlashedIterator{contract: _LockedGold.contract, event: "AccountSlashed", logs: logs, sub: sub}, nil
}

// WatchAccountSlashed is a free log subscription operation binding the contract event 0x7abcb995a115c34a67528d58d5fc5ce02c22cb835ce1685046163f7d366d7111.
//
// Solidity: event AccountSlashed(address indexed slashed, uint256 penalty, address indexed reporter, uint256 reward)
func (_LockedGold *LockedGoldFilterer) WatchAccountSlashed(opts *bind.WatchOpts, sink chan<- *LockedGoldAccountSlashed, slashed []common.Address, reporter []common.Address) (event.Subscription, error) {

	var slashedRule []interface{}
	for _, slashedItem := range slashed {
		slashedRule = append(slashedRule, slashedItem)
	}

	var reporterRule []interface{}
	for _, reporterItem := range reporter {
		reporterRule = append(reporterRule, reporterItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "AccountSlashed", slashedRule, reporterRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldAccountSlashed)
				if err := _LockedGold.contract.UnpackLog(event, "AccountSlashed", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAccountSlashed is a log parse operation binding the contract event 0x7abcb995a115c34a67528d58d5fc5ce02c22cb835ce1685046163f7d366d7111.
//
// Solidity: event AccountSlashed(address indexed slashed, uint256 penalty, address indexed reporter, uint256 reward)
func (_LockedGold *LockedGoldFilterer) ParseAccountSlashed(log types.Log) (*LockedGoldAccountSlashed, error) {
	event := new(LockedGoldAccountSlashed)
	if err := _LockedGold.contract.UnpackLog(event, "AccountSlashed", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldGoldLockedIterator is returned from FilterGoldLocked and is used to iterate over the raw logs and unpacked data for GoldLocked events raised by the LockedGold contract.
type LockedGoldGoldLockedIterator struct {
	Event *LockedGoldGoldLocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldGoldLockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldGoldLocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldGoldLocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldGoldLockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldGoldLockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldGoldLocked represents a GoldLocked event raised by the LockedGold contract.
type LockedGoldGoldLocked struct {
	Account common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGoldLocked is a free log retrieval operation binding the contract event 0x0f0f2fc5b4c987a49e1663ce2c2d65de12f3b701ff02b4d09461421e63e609e7.
//
// Solidity: event GoldLocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) FilterGoldLocked(opts *bind.FilterOpts, account []common.Address) (*LockedGoldGoldLockedIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "GoldLocked", accountRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldGoldLockedIterator{contract: _LockedGold.contract, event: "GoldLocked", logs: logs, sub: sub}, nil
}

// WatchGoldLocked is a free log subscription operation binding the contract event 0x0f0f2fc5b4c987a49e1663ce2c2d65de12f3b701ff02b4d09461421e63e609e7.
//
// Solidity: event GoldLocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) WatchGoldLocked(opts *bind.WatchOpts, sink chan<- *LockedGoldGoldLocked, account []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "GoldLocked", accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldGoldLocked)
				if err := _LockedGold.contract.UnpackLog(event, "GoldLocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGoldLocked is a log parse operation binding the contract event 0x0f0f2fc5b4c987a49e1663ce2c2d65de12f3b701ff02b4d09461421e63e609e7.
//
// Solidity: event GoldLocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) ParseGoldLocked(log types.Log) (*LockedGoldGoldLocked, error) {
	event := new(LockedGoldGoldLocked)
	if err := _LockedGold.contract.UnpackLog(event, "GoldLocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldGoldRelockedIterator is returned from FilterGoldRelocked and is used to iterate over the raw logs and unpacked data for GoldRelocked events raised by the LockedGold contract.
type LockedGoldGoldRelockedIterator struct {
	Event *LockedGoldGoldRelocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldGoldRelockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldGoldRelocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldGoldRelocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldGoldRelockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldGoldRelockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldGoldRelocked represents a GoldRelocked event raised by the LockedGold contract.
type LockedGoldGoldRelocked struct {
	Account common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGoldRelocked is a free log retrieval operation binding the contract event 0xa823fc38a01c2f76d7057a79bb5c317710f26f7dbdea78634598d5519d0f7cb0.
//
// Solidity: event GoldRelocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) FilterGoldRelocked(opts *bind.FilterOpts, account []common.Address) (*LockedGoldGoldRelockedIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "GoldRelocked", accountRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldGoldRelockedIterator{contract: _LockedGold.contract, event: "GoldRelocked", logs: logs, sub: sub}, nil
}

// WatchGoldRelocked is a free log subscription operation binding the contract event 0xa823fc38a01c2f76d7057a79bb5c317710f26f7dbdea78634598d5519d0f7cb0.
//
// Solidity: event GoldRelocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) WatchGoldRelocked(opts *bind.WatchOpts, sink chan<- *LockedGoldGoldRelocked, account []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "GoldRelocked", accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldGoldRelocked)
				if err := _LockedGold.contract.UnpackLog(event, "GoldRelocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGoldRelocked is a log parse operation binding the contract event 0xa823fc38a01c2f76d7057a79bb5c317710f26f7dbdea78634598d5519d0f7cb0.
//
// Solidity: event GoldRelocked(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) ParseGoldRelocked(log types.Log) (*LockedGoldGoldRelocked, error) {
	event := new(LockedGoldGoldRelocked)
	if err := _LockedGold.contract.UnpackLog(event, "GoldRelocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldGoldUnlockedIterator is returned from FilterGoldUnlocked and is used to iterate over the raw logs and unpacked data for GoldUnlocked events raised by the LockedGold contract.
type LockedGoldGoldUnlockedIterator struct {
	Event *LockedGoldGoldUnlocked // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldGoldUnlockedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldGoldUnlocked)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldGoldUnlocked)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldGoldUnlockedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldGoldUnlockedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldGoldUnlocked represents a GoldUnlocked event raised by the LockedGold contract.
type LockedGoldGoldUnlocked struct {
	Account   common.Address
	Value     *big.Int
	Available *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterGoldUnlocked is a free log retrieval operation binding the contract event 0xb1a3aef2a332070da206ad1868a5e327f5aa5144e00e9a7b40717c153158a588.
//
// Solidity: event GoldUnlocked(address indexed account, uint256 value, uint256 available)
func (_LockedGold *LockedGoldFilterer) FilterGoldUnlocked(opts *bind.FilterOpts, account []common.Address) (*LockedGoldGoldUnlockedIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "GoldUnlocked", accountRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldGoldUnlockedIterator{contract: _LockedGold.contract, event: "GoldUnlocked", logs: logs, sub: sub}, nil
}

// WatchGoldUnlocked is a free log subscription operation binding the contract event 0xb1a3aef2a332070da206ad1868a5e327f5aa5144e00e9a7b40717c153158a588.
//
// Solidity: event GoldUnlocked(address indexed account, uint256 value, uint256 available)
func (_LockedGold *LockedGoldFilterer) WatchGoldUnlocked(opts *bind.WatchOpts, sink chan<- *LockedGoldGoldUnlocked, account []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "GoldUnlocked", accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldGoldUnlocked)
				if err := _LockedGold.contract.UnpackLog(event, "GoldUnlocked", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGoldUnlocked is a log parse operation binding the contract event 0xb1a3aef2a332070da206ad1868a5e327f5aa5144e00e9a7b40717c153158a588.
//
// Solidity: event GoldUnlocked(address indexed account, uint256 value, uint256 available)
func (_LockedGold *LockedGoldFilterer) ParseGoldUnlocked(log types.Log) (*LockedGoldGoldUnlocked, error) {
	event := new(LockedGoldGoldUnlocked)
	if err := _LockedGold.contract.UnpackLog(event, "GoldUnlocked", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldGoldWithdrawnIterator is returned from FilterGoldWithdrawn and is used to iterate over the raw logs and unpacked data for GoldWithdrawn events raised by the LockedGold contract.
type LockedGoldGoldWithdrawnIterator struct {
	Event *LockedGoldGoldWithdrawn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldGoldWithdrawnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldGoldWithdrawn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldGoldWithdrawn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldGoldWithdrawnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldGoldWithdrawnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldGoldWithdrawn represents a GoldWithdrawn event raised by the LockedGold contract.
type LockedGoldGoldWithdrawn struct {
	Account common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterGoldWithdrawn is a free log retrieval operation binding the contract event 0x292d39ba701489b7f640c83806d3eeabe0a32c9f0a61b49e95612ebad42211cd.
//
// Solidity: event GoldWithdrawn(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) FilterGoldWithdrawn(opts *bind.FilterOpts, account []common.Address) (*LockedGoldGoldWithdrawnIterator, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "GoldWithdrawn", accountRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldGoldWithdrawnIterator{contract: _LockedGold.contract, event: "GoldWithdrawn", logs: logs, sub: sub}, nil
}

// WatchGoldWithdrawn is a free log subscription operation binding the contract event 0x292d39ba701489b7f640c83806d3eeabe0a32c9f0a61b49e95612ebad42211cd.
//
// Solidity: event GoldWithdrawn(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) WatchGoldWithdrawn(opts *bind.WatchOpts, sink chan<- *LockedGoldGoldWithdrawn, account []common.Address) (event.Subscription, error) {

	var accountRule []interface{}
	for _, accountItem := range account {
		accountRule = append(accountRule, accountItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "GoldWithdrawn", accountRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldGoldWithdrawn)
				if err := _LockedGold.contract.UnpackLog(event, "GoldWithdrawn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseGoldWithdrawn is a log parse operation binding the contract event 0x292d39ba701489b7f640c83806d3eeabe0a32c9f0a61b49e95612ebad42211cd.
//
// Solidity: event GoldWithdrawn(address indexed account, uint256 value)
func (_LockedGold *LockedGoldFilterer) ParseGoldWithdrawn(log types.Log) (*LockedGoldGoldWithdrawn, error) {
	event := new(LockedGoldGoldWithdrawn)
	if err := _LockedGold.contract.UnpackLog(event, "GoldWithdrawn", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldOwnershipTransferredIterator is returned from FilterOwnershipTransferred and is used to iterate over the raw logs and unpacked data for OwnershipTransferred events raised by the LockedGold contract.
type LockedGoldOwnershipTransferredIterator struct {
	Event *LockedGoldOwnershipTransferred // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldOwnershipTransferredIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldOwnershipTransferred)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldOwnershipTransferred)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldOwnershipTransferredIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldOwnershipTransferredIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldOwnershipTransferred represents a OwnershipTransferred event raised by the LockedGold contract.
type LockedGoldOwnershipTransferred struct {
	PreviousOwner common.Address
	NewOwner      common.Address
	Raw           types.Log // Blockchain specific contextual infos
}

// FilterOwnershipTransferred is a free log retrieval operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_LockedGold *LockedGoldFilterer) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*LockedGoldOwnershipTransferredIterator, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldOwnershipTransferredIterator{contract: _LockedGold.contract, event: "OwnershipTransferred", logs: logs, sub: sub}, nil
}

// WatchOwnershipTransferred is a free log subscription operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_LockedGold *LockedGoldFilterer) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *LockedGoldOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {

	var previousOwnerRule []interface{}
	for _, previousOwnerItem := range previousOwner {
		previousOwnerRule = append(previousOwnerRule, previousOwnerItem)
	}
	var newOwnerRule []interface{}
	for _, newOwnerItem := range newOwner {
		newOwnerRule = append(newOwnerRule, newOwnerItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "OwnershipTransferred", previousOwnerRule, newOwnerRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldOwnershipTransferred)
				if err := _LockedGold.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseOwnershipTransferred is a log parse operation binding the contract event 0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0.
//
// Solidity: event OwnershipTransferred(address indexed previousOwner, address indexed newOwner)
func (_LockedGold *LockedGoldFilterer) ParseOwnershipTransferred(log types.Log) (*LockedGoldOwnershipTransferred, error) {
	event := new(LockedGoldOwnershipTransferred)
	if err := _LockedGold.contract.UnpackLog(event, "OwnershipTransferred", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldRegistrySetIterator is returned from FilterRegistrySet and is used to iterate over the raw logs and unpacked data for RegistrySet events raised by the LockedGold contract.
type LockedGoldRegistrySetIterator struct {
	Event *LockedGoldRegistrySet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldRegistrySetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldRegistrySet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldRegistrySet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldRegistrySetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldRegistrySetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldRegistrySet represents a RegistrySet event raised by the LockedGold contract.
type LockedGoldRegistrySet struct {
	RegistryAddress common.Address
	Raw             types.Log // Blockchain specific contextual infos
}

// FilterRegistrySet is a free log retrieval operation binding the contract event 0x27fe5f0c1c3b1ed427cc63d0f05759ffdecf9aec9e18d31ef366fc8a6cb5dc3b.
//
// Solidity: event RegistrySet(address indexed registryAddress)
func (_LockedGold *LockedGoldFilterer) FilterRegistrySet(opts *bind.FilterOpts, registryAddress []common.Address) (*LockedGoldRegistrySetIterator, error) {

	var registryAddressRule []interface{}
	for _, registryAddressItem := range registryAddress {
		registryAddressRule = append(registryAddressRule, registryAddressItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "RegistrySet", registryAddressRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldRegistrySetIterator{contract: _LockedGold.contract, event: "RegistrySet", logs: logs, sub: sub}, nil
}

// WatchRegistrySet is a free log subscription operation binding the contract event 0x27fe5f0c1c3b1ed427cc63d0f05759ffdecf9aec9e18d31ef366fc8a6cb5dc3b.
//
// Solidity: event RegistrySet(address indexed registryAddress)
func (_LockedGold *LockedGoldFilterer) WatchRegistrySet(opts *bind.WatchOpts, sink chan<- *LockedGoldRegistrySet, registryAddress []common.Address) (event.Subscription, error) {

	var registryAddressRule []interface{}
	for _, registryAddressItem := range registryAddress {
		registryAddressRule = append(registryAddressRule, registryAddressItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "RegistrySet", registryAddressRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldRegistrySet)
				if err := _LockedGold.contract.UnpackLog(event, "RegistrySet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseRegistrySet is a log parse operation binding the contract event 0x27fe5f0c1c3b1ed427cc63d0f05759ffdecf9aec9e18d31ef366fc8a6cb5dc3b.
//
// Solidity: event RegistrySet(address indexed registryAddress)
func (_LockedGold *LockedGoldFilterer) ParseRegistrySet(log types.Log) (*LockedGoldRegistrySet, error) {
	event := new(LockedGoldRegistrySet)
	if err := _LockedGold.contract.UnpackLog(event, "RegistrySet", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldSlasherWhitelistAddedIterator is returned from FilterSlasherWhitelistAdded and is used to iterate over the raw logs and unpacked data for SlasherWhitelistAdded events raised by the LockedGold contract.
type LockedGoldSlasherWhitelistAddedIterator struct {
	Event *LockedGoldSlasherWhitelistAdded // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldSlasherWhitelistAddedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldSlasherWhitelistAdded)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldSlasherWhitelistAdded)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldSlasherWhitelistAddedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldSlasherWhitelistAddedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldSlasherWhitelistAdded represents a SlasherWhitelistAdded event raised by the LockedGold contract.
type LockedGoldSlasherWhitelistAdded struct {
	SlasherIdentifier common.Hash
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSlasherWhitelistAdded is a free log retrieval operation binding the contract event 0x92a16cb9e1846d175c3007fc61953d186452c9ea1aa34183eb4b7f88cd3f07bb.
//
// Solidity: event SlasherWhitelistAdded(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) FilterSlasherWhitelistAdded(opts *bind.FilterOpts, slasherIdentifier []string) (*LockedGoldSlasherWhitelistAddedIterator, error) {

	var slasherIdentifierRule []interface{}
	for _, slasherIdentifierItem := range slasherIdentifier {
		slasherIdentifierRule = append(slasherIdentifierRule, slasherIdentifierItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "SlasherWhitelistAdded", slasherIdentifierRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldSlasherWhitelistAddedIterator{contract: _LockedGold.contract, event: "SlasherWhitelistAdded", logs: logs, sub: sub}, nil
}

// WatchSlasherWhitelistAdded is a free log subscription operation binding the contract event 0x92a16cb9e1846d175c3007fc61953d186452c9ea1aa34183eb4b7f88cd3f07bb.
//
// Solidity: event SlasherWhitelistAdded(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) WatchSlasherWhitelistAdded(opts *bind.WatchOpts, sink chan<- *LockedGoldSlasherWhitelistAdded, slasherIdentifier []string) (event.Subscription, error) {

	var slasherIdentifierRule []interface{}
	for _, slasherIdentifierItem := range slasherIdentifier {
		slasherIdentifierRule = append(slasherIdentifierRule, slasherIdentifierItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "SlasherWhitelistAdded", slasherIdentifierRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldSlasherWhitelistAdded)
				if err := _LockedGold.contract.UnpackLog(event, "SlasherWhitelistAdded", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSlasherWhitelistAdded is a log parse operation binding the contract event 0x92a16cb9e1846d175c3007fc61953d186452c9ea1aa34183eb4b7f88cd3f07bb.
//
// Solidity: event SlasherWhitelistAdded(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) ParseSlasherWhitelistAdded(log types.Log) (*LockedGoldSlasherWhitelistAdded, error) {
	event := new(LockedGoldSlasherWhitelistAdded)
	if err := _LockedGold.contract.UnpackLog(event, "SlasherWhitelistAdded", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldSlasherWhitelistRemovedIterator is returned from FilterSlasherWhitelistRemoved and is used to iterate over the raw logs and unpacked data for SlasherWhitelistRemoved events raised by the LockedGold contract.
type LockedGoldSlasherWhitelistRemovedIterator struct {
	Event *LockedGoldSlasherWhitelistRemoved // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldSlasherWhitelistRemovedIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldSlasherWhitelistRemoved)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldSlasherWhitelistRemoved)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldSlasherWhitelistRemovedIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldSlasherWhitelistRemovedIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldSlasherWhitelistRemoved represents a SlasherWhitelistRemoved event raised by the LockedGold contract.
type LockedGoldSlasherWhitelistRemoved struct {
	SlasherIdentifier common.Hash
	Raw               types.Log // Blockchain specific contextual infos
}

// FilterSlasherWhitelistRemoved is a free log retrieval operation binding the contract event 0xaee8df56d95b5766042c2ff4dcb39a120f0a09dd21bb9c143f86a314eff4b714.
//
// Solidity: event SlasherWhitelistRemoved(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) FilterSlasherWhitelistRemoved(opts *bind.FilterOpts, slasherIdentifier []string) (*LockedGoldSlasherWhitelistRemovedIterator, error) {

	var slasherIdentifierRule []interface{}
	for _, slasherIdentifierItem := range slasherIdentifier {
		slasherIdentifierRule = append(slasherIdentifierRule, slasherIdentifierItem)
	}

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "SlasherWhitelistRemoved", slasherIdentifierRule)
	if err != nil {
		return nil, err
	}
	return &LockedGoldSlasherWhitelistRemovedIterator{contract: _LockedGold.contract, event: "SlasherWhitelistRemoved", logs: logs, sub: sub}, nil
}

// WatchSlasherWhitelistRemoved is a free log subscription operation binding the contract event 0xaee8df56d95b5766042c2ff4dcb39a120f0a09dd21bb9c143f86a314eff4b714.
//
// Solidity: event SlasherWhitelistRemoved(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) WatchSlasherWhitelistRemoved(opts *bind.WatchOpts, sink chan<- *LockedGoldSlasherWhitelistRemoved, slasherIdentifier []string) (event.Subscription, error) {

	var slasherIdentifierRule []interface{}
	for _, slasherIdentifierItem := range slasherIdentifier {
		slasherIdentifierRule = append(slasherIdentifierRule, slasherIdentifierItem)
	}

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "SlasherWhitelistRemoved", slasherIdentifierRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldSlasherWhitelistRemoved)
				if err := _LockedGold.contract.UnpackLog(event, "SlasherWhitelistRemoved", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseSlasherWhitelistRemoved is a log parse operation binding the contract event 0xaee8df56d95b5766042c2ff4dcb39a120f0a09dd21bb9c143f86a314eff4b714.
//
// Solidity: event SlasherWhitelistRemoved(string indexed slasherIdentifier)
func (_LockedGold *LockedGoldFilterer) ParseSlasherWhitelistRemoved(log types.Log) (*LockedGoldSlasherWhitelistRemoved, error) {
	event := new(LockedGoldSlasherWhitelistRemoved)
	if err := _LockedGold.contract.UnpackLog(event, "SlasherWhitelistRemoved", log); err != nil {
		return nil, err
	}
	return event, nil
}

// LockedGoldUnlockingPeriodSetIterator is returned from FilterUnlockingPeriodSet and is used to iterate over the raw logs and unpacked data for UnlockingPeriodSet events raised by the LockedGold contract.
type LockedGoldUnlockingPeriodSetIterator struct {
	Event *LockedGoldUnlockingPeriodSet // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *LockedGoldUnlockingPeriodSetIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(LockedGoldUnlockingPeriodSet)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(LockedGoldUnlockingPeriodSet)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *LockedGoldUnlockingPeriodSetIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *LockedGoldUnlockingPeriodSetIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// LockedGoldUnlockingPeriodSet represents a UnlockingPeriodSet event raised by the LockedGold contract.
type LockedGoldUnlockingPeriodSet struct {
	Period *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterUnlockingPeriodSet is a free log retrieval operation binding the contract event 0xd9274a7c98edc7c66931fc71872764091e7023fe3867358f8504d4c21b161fc5.
//
// Solidity: event UnlockingPeriodSet(uint256 period)
func (_LockedGold *LockedGoldFilterer) FilterUnlockingPeriodSet(opts *bind.FilterOpts) (*LockedGoldUnlockingPeriodSetIterator, error) {

	logs, sub, err := _LockedGold.contract.FilterLogs(opts, "UnlockingPeriodSet")
	if err != nil {
		return nil, err
	}
	return &LockedGoldUnlockingPeriodSetIterator{contract: _LockedGold.contract, event: "UnlockingPeriodSet", logs: logs, sub: sub}, nil
}

// WatchUnlockingPeriodSet is a free log subscription operation binding the contract event 0xd9274a7c98edc7c66931fc71872764091e7023fe3867358f8504d4c21b161fc5.
//
// Solidity: event UnlockingPeriodSet(uint256 period)
func (_LockedGold *LockedGoldFilterer) WatchUnlockingPeriodSet(opts *bind.WatchOpts, sink chan<- *LockedGoldUnlockingPeriodSet) (event.Subscription, error) {

	logs, sub, err := _LockedGold.contract.WatchLogs(opts, "UnlockingPeriodSet")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(LockedGoldUnlockingPeriodSet)
				if err := _LockedGold.contract.UnpackLog(event, "UnlockingPeriodSet", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseUnlockingPeriodSet is a log parse operation binding the contract event 0xd9274a7c98edc7c66931fc71872764091e7023fe3867358f8504d4c21b161fc5.
//
// Solidity: event UnlockingPeriodSet(uint256 period)
func (_LockedGold *LockedGoldFilterer) ParseUnlockingPeriodSet(log types.Log) (*LockedGoldUnlockingPeriodSet, error) {
	event := new(LockedGoldUnlockingPeriodSet)
	if err := _LockedGold.contract.UnpackLog(event, "UnlockingPeriodSet", log); err != nil {
		return nil, err
	}
	return event, nil
}
